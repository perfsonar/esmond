<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>perfSONAR Perl Client Libraries &mdash; esmond</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.1.0/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/esnet/esnet.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.9.1a1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="esmond" href="index.html" />
    <link rel="next" title="Developer Reference" href="api.html" />
    <link rel="prev" title="perfSONAR Python Client Libraries" href="perfsonar_client_python.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          <!-- LOGO: logo-esnet-ball-sm.png _static/logo-esnet-ball-sm.png --><img src="_static/logo-esnet-ball-sm.png">
          esmond</a>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Section <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="config.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="deployment_cookbook.html">Deployment Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="rpm_install.html">RPM Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">esmond subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.client.html">REST API Client Libary</a></li>
<li class="toctree-l1"><a class="reference internal" href="hacking.html">Hacking on esmond</a></li>
<li class="toctree-l1"><a class="reference internal" href="perfsonar_extension.html">Extending the perfSONAR API</a></li>
<li class="toctree-l1"><a class="reference internal" href="rpm_build.html">RPM Build Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="perfsonar_client_rest.html">perfSONAR Client REST Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="perfsonar_client_python.html">perfSONAR Python Client Libraries</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">perfSONAR Perl Client Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">Developer Reference</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="perfsonar_client_python.html" title="Previous Chapter: perfSONAR Python Client Libraries">
      <span class="glyphicon glyphicon-chevron-left"></span>
      <span class="hidden-sm">
        perfSONAR Python...
      </span>
    </a>
  </li>
  <li>
    <a href="api.html" title="Next Chapter: Developer Reference">
      <span class="hidden-sm">
        Developer Refere...
      </span>
      <span class="glyphicon glyphicon-chevron-right"></span>
    </a>
  </li>
              
            
            <li class="divider-vertical"></li>
            
                <li><a href="genindex.html">Index</a></li>
                <li><a href="https://www.es.net">ESnet</a></li>
            
            <li><a href="http://github.com/esnet/esmond"><img src="_static/esnet/icon-github.png" height="20" width="20"></a></li>
            
            
            
          </ul>
          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">perfSONAR Perl Client Libraries</a><ul>
<li><a class="reference internal" href="#where-to-get-the-api">Where to get the API</a></li>
<li><a class="reference internal" href="#querying-data">Querying Data</a><ul>
<li><a class="reference internal" href="#quickstart">Quickstart</a></li>
<li><a class="reference internal" href="#defining-filters">Defining filters</a></li>
<li><a class="reference internal" href="#connecting-to-the-api">Connecting to the API</a></li>
<li><a class="reference internal" href="#working-with-measurement-metadata">Working with Measurement Metadata</a></li>
<li><a class="reference internal" href="#querying-base-measurement-results">Querying Base Measurement Results</a></li>
<li><a class="reference internal" href="#querying-summary-measurement-results">Querying Summary Measurement Results</a></li>
<li><a class="reference internal" href="#advanced-time-filter-usage">Advanced Time Filter Usage</a></li>
<li><a class="reference internal" href="#pagination-of-metadata-search-results">Pagination of Metadata Search Results</a></li>
<li><a class="reference internal" href="#querying-data-by-uri">Querying Data by URI</a></li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#querying-throughput">Querying Throughput</a></li>
<li><a class="reference internal" href="#querying-delay-one-way-delay">Querying Delay/One-way Delay</a></li>
<li><a class="reference internal" href="#querying-packet-loss">Querying Packet Loss</a></li>
<li><a class="reference internal" href="#querying-packet-traces">Querying Packet Traces</a></li>
<li><a class="reference internal" href="#querying-subintervals">Querying Subintervals</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#publishing-data">Publishing Data</a><ul>
<li><a class="reference internal" href="#id1">Quickstart</a></li>
<li><a class="reference internal" href="#authentication-and-authorization">Authentication and Authorization</a></li>
<li><a class="reference internal" href="#publishing-the-measurement-description">Publishing the Measurement Description</a></li>
<li><a class="reference internal" href="#publishing-a-single-measurement-result">Publishing a Single Measurement Result</a></li>
<li><a class="reference internal" href="#publishing-multiple-measurement-results">Publishing Multiple Measurement Results</a></li>
<li><a class="reference internal" href="#id2">Examples</a><ul>
<li><a class="reference internal" href="#publishing-throughput-data">Publishing Throughput Data</a></li>
<li><a class="reference internal" href="#publishing-delay-ping-data">Publishing Delay(Ping) Data</a></li>
<li><a class="reference internal" href="#publishing-one-way-delay-owamp-data">Publishing One-way Delay(OWAMP) Data</a></li>
<li><a class="reference internal" href="#publishing-packet-loss">Publishing Packet Loss</a></li>
<li><a class="reference internal" href="#publishing-packet-traces">Publishing Packet Traces</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="col-md-9">
      
  <div class="section" id="perfsonar-perl-client-libraries">
<h1>perfSONAR Perl Client Libraries<a class="headerlink" href="#perfsonar-perl-client-libraries" title="Permalink to this headline">¶</a></h1>
<p>This document describes the basics of reading and writing data from the perfSONAR measurement archive using the PERL API. The measurement archive implements a REST interface where clients can retrieve descriptions of measurements being run and the results of those measurements. It currently offers support for a range of measurements related to throughput, packet delay, packet loss, packet traces and more (with additional data types being added all the time). This document gives developers information on how to interact with the API using the Perl library.</p>
<div class="section" id="where-to-get-the-api">
<h2>Where to get the API<a class="headerlink" href="#where-to-get-the-api" title="Permalink to this headline">¶</a></h2>
<p>The API can currently be found in the perfsonar shared <a class="reference external" href="https://github.com/perfsonar/perl-shared">perl source tree</a>. You will find the client libraries under <cite>lib/perfSONAR_PS/Client/Esmond</cite>. You may add these as a git submodule to your own project. Assuming you keep your Perl files under <cite>lib</cite> you can include them as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>git submodule add https://github.com/perfsonar/perl-shared shared
mkdir -p lib/perfSONAR_PS/Client/Esmond
cd lib/perfSONAR_PS/Client/Esmond
ln -s ../../../../shared/lib/perfSONAR_PS/Client/Esmond/* .
</pre></div>
</div>
</div>
<div class="section" id="querying-data">
<h2>Querying Data<a class="headerlink" href="#querying-data" title="Permalink to this headline">¶</a></h2>
<div class="section" id="quickstart">
<h3>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre># Define filters
my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters();
$filters-&gt;source(&quot;host1.example.net&quot;);
$filters-&gt;destination(&quot;host2.example.net&quot;);
$filters-&gt;time_range(86400);
$filters-&gt;event_type(&#39;throughput&#39;);

# Connect to api
my $client = new perfSONAR_PS::Client::Esmond::ApiConnect(
    url =&gt; &#39;http://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);

#get measurements matching filters
my $md = $client-&gt;get_metadata();
die $client-&gt;error if($client-&gt;error); #check for errors
#loop through all measurements
foreach my $m(@{$md}){
    # get data of a particular event type
    my $et = $m-&gt;get_event_type(&quot;throughput&quot;);
    my $data = $et-&gt;get_data();
    die $et-&gt;error if($et-&gt;error); #check for errors
    #print all data
    foreach my $d(@{$data}){
        print &quot;Time: &quot; . $d-&gt;datetime . &quot;, Value: &quot; . $d-&gt;val . &quot;\n&quot;;
    }
}
</pre></div>
</div>
</div>
<div class="section" id="defining-filters">
<span id="psclient-perl-filters"></span><h3>Defining filters<a class="headerlink" href="#defining-filters" title="Permalink to this headline">¶</a></h3>
<p>The first step to querying the measurement archive is to define a set of filters. If you want a listing of all the measurements run by a measurement archive using default HTTP connection parameters then you can skip this step. The library allows you to filter measurements using the <strong>perfSONAR_PS::Client::Esmond::ApiFilters</strong> module. The class has a a set of well-known filters available as specific functions and also allows the setting of custom filters with direct access to the <em>metadata_filters</em> hash. It also allows you to define various settings related to the HTTP connection. In general, you can call the constructor without any options as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters();
</pre></div>
</div>
<p>You can optionally pass the following values to the ApiFilters constructor when creating a new object:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Property Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>auth_username</strong></td>
<td>String with the username to pass in the HTTP Authorization header. Not required for querying data, but may be required to write data.</td>
</tr>
<tr class="row-odd"><td><strong>auth_apikey</strong></td>
<td>String with the API key to pass in the HTTP Authorization header. Not required for querying data, but may be required to write data.</td>
</tr>
<tr class="row-even"><td><strong>ca_certificate_file</strong></td>
<td>For HTTPS connections only, the absolute path to a file containing a certificate file used to verify the server certificate</td>
</tr>
<tr class="row-odd"><td><strong>ca_certificate_path</strong></td>
<td>For HTTPS connections only, the absolute path to a directory containing one or more certificate files to be used to verify the server</td>
</tr>
<tr class="row-even"><td><strong>timeout</strong></td>
<td>The timeout in seconds to wait before terminating the HTTP request. Defaults to 60 seconds.</td>
</tr>
<tr class="row-odd"><td><strong>verify_hostname</strong></td>
<td>For HTTPS connections only, a boolean indicating whether the hostname must match the common name in the subject of the certificate presented by the server.</td>
</tr>
</tbody>
</table>
<p>After creating the filters object, you can set various parameters that will limit the results returned by the search by using a set of accessor methods. The methods accept an optional argument containing the value to set. If no argument is provided, it simply returns the value of the field. The full set of methods available for setting common values is provided below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Method Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>source(ip)</strong></td>
<td>An IP address or hostname matching against the sender in a measurement. Hostnames will automatically get mapped to IP addresses by the server, so no need to match the form in which things are stored on the backend.</td>
</tr>
<tr class="row-odd"><td><strong>destination(ip)</strong></td>
<td>An IP address or hostname matching against the receiver in a measurement. Hostnames will automatically get mapped to IP addresses by the server, so no need to match the form in which things are stored on the backend.</td>
</tr>
<tr class="row-even"><td><strong>measurement_agent(ip)</strong></td>
<td>An IP address or hostname matching against the host that initiated a test. Could either be the source, destination or in some cases a third-party host. Hostnames will automatically get mapped to IP addresses by the server, so no need to match the form in which things are stored on the backend.</td>
</tr>
<tr class="row-odd"><td><strong>tool_name(string)</strong></td>
<td>The name of the tool used for the measurement. Examples include <em>bwctl/iperf3</em> and <em>powstream</em>.</td>
</tr>
<tr class="row-even"><td><strong>event_type(string)</strong></td>
<td>Matches only metadata with a certain type for data (e.g. <em>throughput</em>, <em>packet-loss-rate</em>)</td>
</tr>
<tr class="row-odd"><td><strong>summary_type(string)</strong></td>
<td>Matches only metadata doing certain summaries(e.g. <em>statistics</em>, <em>average</em>, <em>aggregation</em>)</td>
</tr>
<tr class="row-even"><td><strong>summary_window(seconds)</strong></td>
<td>Matches only metadata with event-types that have summaries over a certain windows (in seconds).</td>
</tr>
<tr class="row-odd"><td><strong>time(timestamp)</strong></td>
<td>Match metadata last updated at the exact time given as a UNIX timestamp.</td>
</tr>
<tr class="row-even"><td><strong>time_start(timestamp)</strong></td>
<td>Match only measurements that were updated after the given time (inclusive). If time_end nor time_range is defined, then it will return all results from the start time to the current time. In UNIX timestamp format.</td>
</tr>
<tr class="row-odd"><td><strong>time_end(timestamp)</strong></td>
<td>Match only data that was measured before the given time (inclusive). If time-start nor time-range is provided, then will return all data stored in the archive up to and including the end time. In UNIX timestamp format.</td>
</tr>
<tr class="row-even"><td><strong>time_range(seconds)</strong></td>
<td>Only return results that have been updated in the given number of seconds in the past. If time_start nor time-end is defined, then it is the number of seconds in the past from the current time. If only time_start is defined then it is the number of seconds after time_start to search. If only time_end is provided it is the number of seconds before end time to search. If both time_start and time_end are defined, this value is ignored.</td>
</tr>
<tr class="row-odd"><td><strong>input_source(string)</strong></td>
<td>A string indicating exactly how the source address is passed to the tool. <strong>You SHOULD NOT search on this field, use the source instead.</strong> This field is for informational purposes only to indicate whether the underlying tool running the measurement (e.g. bwctl, owping, ping) is passed a DNS name or IP when it runs. While searching is not strictly prohibited, you should almost never search on this field. The source is better since it will do DNS to IP mappings and will provide more consistent</td>
</tr>
<tr class="row-even"><td><strong>input_destination(string)</strong></td>
<td>A string indicating exactly how the destination address is passed to the tool. <strong>You SHOULD NOT search on this field, use the destination instead.</strong>  See <em>input-source</em> above for a complete discussion.</td>
</tr>
<tr class="row-odd"><td><strong>dns_match_rule(string)</strong></td>
<td>A string indicating how to handle DNS lookups on fields such as <em>source</em>, <em>destination</em> and <em>measurement_agent</em> where the server maps DNS names to IP addresses. See <a class="reference internal" href="perfsonar_client_rest.html#psclient-rest-search"><em>Searching by Endpoint</em></a> for valid values. Also see the <tt class="docutils literal"><span class="pre">dns_match_**</span></tt> subroutines below for convenience functions that set this same field to specific values.</td>
</tr>
<tr class="row-even"><td><strong>dns_match_only_v4()</strong></td>
<td>Alias for <tt class="docutils literal"><span class="pre">dns_match_rule('only-v4')</span></tt>. Only maps given DNS names to their A records when searching</td>
</tr>
<tr class="row-odd"><td><strong>dns_match_only_v6()</strong></td>
<td>Alias for <tt class="docutils literal"><span class="pre">dns_match_rule('only-v6')</span></tt>. Only maps given DNS names to their AAAA records when searching</td>
</tr>
<tr class="row-even"><td><strong>dns_match_prefer_v4()</strong></td>
<td>Alias for <tt class="docutils literal"><span class="pre">dns_match_rule('prefer-v4')</span></tt>. Maps given DNS names to their A record if they have one, otherwise tries AAAA record</td>
</tr>
<tr class="row-odd"><td><strong>dns_match_prefer_v6()</strong></td>
<td>Alias for <tt class="docutils literal"><span class="pre">dns_match_rule('prefer-v6')</span></tt>. Maps given DNS names to their AAAA record if they have one, otherwise tries A record</td>
</tr>
<tr class="row-even"><td><strong>dns_match_all()</strong></td>
<td>Alias for <tt class="docutils literal"><span class="pre">dns_match_rule('v4v6')</span></tt>. Maps DNS names to both A and AAAA records when searching. This is the default behavior if * dns_match_rule* is unspecified</td>
</tr>
<tr class="row-odd"><td><strong>limit()</strong></td>
<td>An integer indicating the maximum number of metadata objects to return. If not set, all results will be returned.</td>
</tr>
<tr class="row-even"><td><strong>offset()</strong></td>
<td>An integer indicating the number of results to skip in the metadata search. This can be combined with the <em>limit</em> filter to support pagination. See <a class="reference internal" href="#psclient-perl-pagination"><em>Pagination of Metadata Search Results</em></a> for more details.</td>
</tr>
</tbody>
</table>
<p>Finally, you can set context-specific parameters that don&#8217;t have a function by accessing the <em>metadata``_``filters</em> hash directly:</p>
<div class="highlight-python"><div class="highlight"><pre>$filters-&gt;metadata_filters-&gt;{&#39;ip-transport-protocol&#39;} = &#39;tcp&#39;;
</pre></div>
</div>
</div>
<div class="section" id="connecting-to-the-api">
<span id="psclient-perl-connect"></span><h3>Connecting to the API<a class="headerlink" href="#connecting-to-the-api" title="Permalink to this headline">¶</a></h3>
<p>Once the filters are defined, you create an instance of <strong>perfSONAR_PS::Client::Esmond::ApiConnect</strong> as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>...
my $client = new perfSONAR_PS::Client::Esmond::ApiConnect(
    url =&gt; &#39;http://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);
</pre></div>
</div>
<p>You MUST provide the <em>url</em> parameter with the base URL of the measurement archive (usually ending with <em>/esmond/perfsonar/archive</em>) in the constructor. You may optionally define the <em>filters</em> field in the constructor with an instance of <strong>perfSONAR_PS::Client::Esmond::ApiFilters</strong>. If none is provided, all metadata will be returned and default HTTP connection settings will be used. After constructing the ApiConnect object, there is one method, <strong>get_metadata()</strong>, that accepts no arguments available to call:</p>
<div class="highlight-python"><div class="highlight"><pre>...
my $md = $client-&gt;get_metadata();
</pre></div>
</div>
<p>The <strong>get_metadata()</strong> call returns an ArrayRef to a list of <strong>perfSONAR_PS::Client::Esmond::Metadata</strong> objects as described in <a class="reference internal" href="#psclient-perl-metadata"><em>Working with Measurement Metadata</em></a>. After making a call to <strong>get_metadata()</strong> you can check the <strong>error</strong> property to see if any errors occurred since <strong>get_metadata()</strong> leads to an HTTP GET request. For example:</p>
<div class="highlight-python"><div class="highlight"><pre>...
my $md = $client-&gt;get_metadata();
die $client-&gt;error if($client-&gt;error); #check for errors
</pre></div>
</div>
</div>
<div class="section" id="working-with-measurement-metadata">
<span id="psclient-perl-metadata"></span><h3>Working with Measurement Metadata<a class="headerlink" href="#working-with-measurement-metadata" title="Permalink to this headline">¶</a></h3>
<p>As discussed in <a class="reference internal" href="#psclient-perl-connect"><em>Connecting to the API</em></a> you can retrieve an ArrayRef to a list of <strong>perfSONAR_PS::Client::Esmond::Metadata</strong> objects. These objects describe tests and have the following property methods to retrieve common metadata parameters:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Method Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>source()</strong></td>
<td>An IP address representing the sender in a point-to-point measurement</td>
</tr>
<tr class="row-odd"><td><strong>destination()</strong></td>
<td>An IP address representing the receiver in a point-to-point measurement</td>
</tr>
<tr class="row-even"><td><strong>measurement_agent()</strong></td>
<td>The IP address of the host that initiated the measurement</td>
</tr>
<tr class="row-odd"><td><strong>metadata_key()</strong></td>
<td>The key used to identify this metadata_object.</td>
</tr>
<tr class="row-even"><td><strong>input_source</strong></td>
<td>A string representing the source address exactly as it is passed to the underlying measurement tool.</td>
</tr>
<tr class="row-odd"><td><strong>input_destination()</strong></td>
<td>A string representing the destination address exactly as it is passed to the underlying measurement tool.</td>
</tr>
<tr class="row-even"><td><strong>subject_type()</strong></td>
<td>Indicates the type of parameters to expect in the metadata. In general will always be <em>point-to-point</em>.</td>
</tr>
<tr class="row-odd"><td><strong>tool_name()</strong></td>
<td>The name of the tool used to run the underlying measurement.</td>
</tr>
<tr class="row-even"><td><strong>uri()</strong></td>
<td>The URI to this individual metadata object</td>
</tr>
<tr class="row-odd"><td><strong>event_types()</strong></td>
<td>Returns an ArrayRef of strings indicating the event type available. e.g. [&#8216;throughput&#8217;, &#8216;packet-count-sent&#8217;]</td>
</tr>
</tbody>
</table>
<p>Additionally, you can retrieve context-specific metadata parameters with the <strong>get_field</strong> call which accepts the field name as a parameter:</p>
<div class="highlight-python"><div class="highlight"><pre>...
foreach my $m(@{$md}){
    print $m-&gt;get_field(&#39;ip-transport-protocol&#39;) . &quot;\n&quot;;
}
</pre></div>
</div>
<p>Finally, there are a special set of methods to work with event types and will act as the gateway to accessing the results. The methods are as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Method Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>get_all_event_types()</strong></td>
<td>Accepts no arguments and returns an ArrayRef of <strong>perfSONAR_PS::Client::Esmond::EventType</strong> objects</td>
</tr>
<tr class="row-odd"><td><strong>get_event_type(string)</strong></td>
<td>Accepts a single argument indicating the type of data you want (e.g.&#8217;throughput&#8217;). Returns a single <strong>perfSONAR_PS::Client::Esmond::EventType</strong> object or undef if none match</td>
</tr>
</tbody>
</table>
<p>An example of each:</p>
<div class="highlight-python"><div class="highlight"><pre>...
#print the base uri for every event type
foreach my $et(@{$m-&gt;get_all_event_types()}){
    print $et-&gt;base_uri() . &quot;\n&quot;;
}

#grab a single throughput event type
my $throughput_et = $m-&gt;get_event_type(&quot;throughput&quot;);
</pre></div>
</div>
</div>
<div class="section" id="querying-base-measurement-results">
<span id="psclient-perl-query-base"></span><h3>Querying Base Measurement Results<a class="headerlink" href="#querying-base-measurement-results" title="Permalink to this headline">¶</a></h3>
<p>The <strong>perfSONAR_PS::Client::Esmond::EventType</strong> is the gateway object to pulling down actual results. It provides the following methods:</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Method Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>base_uri()</strong></td>
<td>Returns the URI where you can get the base data for the event type. See <a class="reference internal" href="perfsonar_client_rest.html#psclient-rest-basevsumm"><em>Base Data vs Summaries</em></a> for more details on base and summary data.</td>
</tr>
<tr class="row-odd"><td><strong>event_type()</strong></td>
<td>The type of data such as <em>throughput</em> or <em>packet-loss-rate</em>.</td>
</tr>
<tr class="row-even"><td><strong>time_updated()</strong></td>
<td>A Unix timestamp indicating when the event type was last updated. A value of undef means it has never been updated.</td>
</tr>
<tr class="row-odd"><td><strong>datetime_updated()</strong></td>
<td>A DateTime object indicating when the event type was last updated. The same as <em>time_updated()</em> but returns a DateTime object instead of a UNIX timestamp.</td>
</tr>
<tr class="row-even"><td><strong>summaries()</strong></td>
<td>An ArrayRef of tuples. The first item in each tuple is the summary type, the second is the summary window.</td>
</tr>
</tbody>
</table>
<p>It provides a single <strong>get_data()</strong> method that accepts no arguments for pulling down data. It also provides an <strong>error</strong> property for checking if the <strong>get_data()</strong> call failed. If <strong>get_data()</strong> succeeds it returns an ArrayRef of <strong>perfSONAR_PS::Client::Esmond::DataPayload</strong> objects. <strong>perfSONAR_PS::Client::Esmond::DataPayload</strong> objects have the following properties:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Property Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>ts</strong></td>
<td>The UNIX timestamp of when the measurement was run</td>
</tr>
<tr class="row-odd"><td><strong>val</strong></td>
<td>The value of the measurement. The type depends on the event type. It will either be a primitive type or a Perl HashRef.</td>
</tr>
</tbody>
</table>
<p>It also contains the following method:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Method Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>datetime()</strong></td>
<td>Returns a DateTime version of the <em>ts</em> property</td>
</tr>
</tbody>
</table>
<p>A full example is shown below:</p>
<div class="highlight-python"><div class="highlight"><pre>...
my $data = $et-&gt;get_data();
die $et-&gt;error if($et-&gt;error); #check for errors
#print all data
foreach my $d(@{$data}){
    print &quot;Time: &quot; . $d-&gt;datetime . &quot;, Value: &quot; . $d-&gt;val . &quot;\n&quot;;
}
</pre></div>
</div>
</div>
<div class="section" id="querying-summary-measurement-results">
<h3>Querying Summary Measurement Results<a class="headerlink" href="#querying-summary-measurement-results" title="Permalink to this headline">¶</a></h3>
<p>The <strong>perfSONAR_PS::Client::Esmond::EventType</strong> contains two more methods for geting summary data:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>get_all_summaries()</strong></td>
<td>Returns an ArrayRef of <strong>perfSONAR_PS::Client::Esmond::Summary</strong> objects. Returns an empty list if there are no summaries.</td>
</tr>
<tr class="row-even"><td><strong>get_summary(string, seconds)</strong></td>
<td>Returns a a single <strong>perfSONAR_PS::Client::Esmond::Summary</strong> of a given type and summary window.</td>
</tr>
</tbody>
</table>
<p>The <strong>perfSONAR_PS::Client::Esmond::Summary</strong> module has the following methods:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Method Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>uri()</strong></td>
<td>Returns the URI where you can get the summary data.</td>
</tr>
<tr class="row-odd"><td><strong>summary_type()</strong></td>
<td>The type of summary such as <em>aggregation</em>, <em>average</em> or <em>statistics</em>.</td>
</tr>
<tr class="row-even"><td><strong>summary_window()</strong></td>
<td>The time in seconds over which the data is summarized.</td>
</tr>
<tr class="row-odd"><td><strong>time_updated()</strong></td>
<td>A Unix timestamp indicating when the summary was last updated. A value of undef means it has never been updated.</td>
</tr>
<tr class="row-even"><td><strong>datetime_updated()</strong></td>
<td>A DateTime object indicating when the summary was last updated. The same as <em>time_updated()</em> but returns a DateTime object instead of a UNIX timestamp.</td>
</tr>
</tbody>
</table>
<p>The <strong>perfSONAR_PS::Client::Esmond::Summary</strong> module also has a <strong>get_data()</strong> method that accepts no arguments and returns an ArrayRef of <strong>perfSONAR_PS::Client::Esmond::DataPayload</strong> objects. It also has an <strong>error</strong> property that gets populated if the library is unable to retrieve the summary. These methods follow the exact same format as the <strong>perfSONAR_PS::Client::Esmond::EventType</strong> module. An example of querying summary data below:</p>
<div class="highlight-python"><div class="highlight"><pre>#get 24 hour summaries
my $agg_summ = $et-&gt;get_summary(&#39;aggregation&#39;, 86400);
die &quot;No summary found&quot; unless($agg_summ);
my $agg_data = $agg_summ-&gt;get_data();
die $agg_summ-&gt;error if($agg_summ-&gt;error);
foreach my $agg_d(@{$agg_data}){
    print &quot;Time: &quot; . $agg_d-&gt;datetime . &quot;, Val: &quot; . $agg_d-&gt;val . &quot;\n&quot;;
}
</pre></div>
</div>
</div>
<div class="section" id="advanced-time-filter-usage">
<h3>Advanced Time Filter Usage<a class="headerlink" href="#advanced-time-filter-usage" title="Permalink to this headline">¶</a></h3>
<p>It&#8217;s important to note an important behavior of the time filters when working with a metadata request versus a data request. When you create a <strong>perfSONAR_PS::Client::Esmond::ApiFilters</strong> object, pass it to a <strong>perfSONAR_PS::Client::Esmond::ApiConnect</strong>, and the call to get_metadata() it will match the <em>last updated</em> time of the metadata. When making a data request, it will only return results <em>recorded in that time range</em>. This is a subtle but important difference. For example, let&#8217;s say you have a metadata object that was last updated 1 minute ago but you ultimately want data from between 2 hours and 1 hour ago. You might be tempted to try something like this:</p>
<div class="highlight-python"><div class="highlight"><pre>my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters();
my $now = time;
$filters-&gt;time_start($now - 7200); # 2 hours ago
$filters-&gt;time_end($now - 3600); #1 hour ago

# Connect to api
my $client = new perfSONAR_PS::Client::Esmond::ApiConnect(
    url =&gt; &#39;http://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);

#get measurements matching filters
my $md = $client-&gt;get_metadata(); # this returns empty results
</pre></div>
</div>
<p>The above returns empty results because the above is saying <em>give me all metadata object last updated between 2 hours and 1 hour ago</em> but we have already stated that our metadata was updated more recently. This does not mean there is no data in that time range, just that more recent data exists. Instead we need to adjust the time filters before we query the data. Below will give the results we want:</p>
<div class="highlight-python"><div class="highlight"><pre>my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters();
my $now = time;
$filters-&gt;time_start($now - 7200); # return anything updated in the last 2 hours

# Connect to api
my $client = new perfSONAR_PS::Client::Esmond::ApiConnect(
    url =&gt; &#39;http://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);

#get measurements matching filters
my $md = $client-&gt;get_metadata(); # this returns empty results
foreach my $m(@{$md}){
    # get data of a particular event type
    my $et = $m-&gt;get_event_type(&quot;throughput&quot;);
    $et-&gt;filters-&gt;time_end($now - 3600); #add the end filter so we only get data up to an hour ago
    my $data = $et-&gt;get_data();
    die $et-&gt;error if($et-&gt;error); #check for errors
    #print all data
    foreach my $d(@{$data}){
        print &quot;Time: &quot; . $d-&gt;datetime . &quot;, Value: &quot; . $d-&gt;val . &quot;\n&quot;;
    }
}
</pre></div>
</div>
</div>
<div class="section" id="pagination-of-metadata-search-results">
<span id="psclient-perl-pagination"></span><h3>Pagination of Metadata Search Results<a class="headerlink" href="#pagination-of-metadata-search-results" title="Permalink to this headline">¶</a></h3>
<p>For measurement archives hosting a large number of tests, it may be desirable to limit the number of metadata search results returned. This can be done using the <em>limit</em> and <em>offset</em> filters as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters();
$filters-&gt;limit(10); #return up to 10 results
$filters-&gt;offset(0); # return the first results you find

# Connect to api
my $client = new perfSONAR_PS::Client::Esmond::ApiConnect(
    url =&gt; &#39;http://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);

#get measurements matching filters
my $md = $client-&gt;get_metadata(); # returns first 10 results
...
$filters-&gt;offset(10); # skip the first 10 results
$md = $client-&gt;get_metadata(); # returns the second 10 results
</pre></div>
</div>
<p>As the example shows you can use these options to implement pagination. This is done by keeping the limit option constant and incrementing the offset by the size of limit for each page until you reach the last page. To aid in common calculations like the last page, current page, and the next/previous offset the <strong>perfSONAR_PS::Client::Esmond::Paginator</strong> class is provided. After you define your filters and query your metadata, you can create a <strong>perfSONAR_PS::Client::Esmond::Paginator</strong> instance as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>my $paginator = new perfSONAR_PS::Client::Esmond::Paginator(
    &#39;metadata&#39; =&gt; $mds,
    &#39;filters&#39; =&gt; $filters,
);
</pre></div>
</div>
<p>As shown in the example the constructor requires the properties below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Property Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>metadata</strong></td>
<td>An ArrayRef of <strong>perfSONAR_PS::Client::Esmond::Metadata</strong> objects (such as the results returned by a get_metadata call).</td>
</tr>
<tr class="row-odd"><td><strong>filters</strong></td>
<td>The <strong>perfSONAR_PS::Client::Esmond::ApiFilters</strong> object used in the query. It is recommended the <em>limit</em> and <em>offset</em> filters are defined for the paginator to be useful.</td>
</tr>
</tbody>
</table>
<p>Once you have created your paginator, the following methods are available:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Method Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>current_page()</strong></td>
<td>Returns the current page number based on the offset and limit. Page count starts at 1.</td>
</tr>
<tr class="row-odd"><td><strong>last_page()</strong></td>
<td>Returns the last page number based on the offset and limit. Page count starts at 1.</td>
</tr>
<tr class="row-even"><td><strong>next_offset()</strong></td>
<td>Calculates the value to pass to the offset to get next page of data. Returns undef if the current page is the last page.</td>
</tr>
<tr class="row-odd"><td><strong>prev_offset()</strong></td>
<td>Calculates the value to pass to the offset to get previous page of data. Returns undef if the current page is the last page.</td>
</tr>
<tr class="row-even"><td><strong>page_offset(page_number)</strong></td>
<td>Calculates the value to pass to the offset for the given page number (starting at 1). If the page number is bigger than the last page undef is returned.</td>
</tr>
</tbody>
</table>
<p>A full example that grabs all the metadata in chunks of 10 and prints the page number is shown below:</p>
<div class="highlight-python"><div class="highlight"><pre>my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters();
$filters-&gt;limit(10);
my $client = new perfSONAR_PS::Client::Esmond::ApiConnect(
    url =&gt; &#39;http://esmond-dev/perfsonar/archive&#39;,
    filters =&gt; $filters
);
my $next = 0;
while(defined $next){
    $filters-&gt;offset($next);
    my $mds = $client-&gt;get_metadata();
    my $paginator = new perfSONAR_PS::Client::Esmond::Paginator(
        &#39;metadata&#39; =&gt; $mds,
        &#39;filters&#39; =&gt; $filters,
    );
    print &quot;Current page is &quot; . $paginator-&gt;current_page() . &quot; of &quot; . $paginator-&gt;last_page() . &quot;\n&quot;;
    $next = $paginator-&gt;next_offset();
}
</pre></div>
</div>
</div>
<div class="section" id="querying-data-by-uri">
<h3>Querying Data by URI<a class="headerlink" href="#querying-data-by-uri" title="Permalink to this headline">¶</a></h3>
<p>In some cases you will already have the URI for the summary or base data that you want to request. For example, if you have a web page that first presents the list of tests available as returned by a metadata search, then upon user interaction you return data from a selected result of that search. There is no point in querying the metadata a second time since you should have all the URIs you need from the first request. You can request the data directly by URI with the <strong>get_data(*uri*)</strong> call from <strong>perfSONAR_PS::Client::Esmond::ApiConnect</strong>. For example:</p>
<div class="highlight-python"><div class="highlight"><pre>...
use CGI;
my $cgi = new CGI;
my $uri = $cgi-&gt;param(&#39;data-uri&#39;);
my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters();
$filters-&gt;time_range(86400);
my $client = new perfSONAR_PS::Client::Esmond::ApiConnect(
    url =&gt; &#39;http://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);
my $data = $client-&gt;get_data($uri);
die $client-&gt;error if($client-&gt;error);
foreach my $d(@{$data}){
    print &quot;Time: &quot; . $d-&gt;datetime . &quot;, Value: &quot; . $d-&gt;val . &quot;\n&quot;;
}
</pre></div>
</div>
</div>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<div class="section" id="querying-throughput">
<h4>Querying Throughput<a class="headerlink" href="#querying-throughput" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre># Define filters
my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters();
$filters-&gt;source(&quot;host1.example.net&quot;);
$filters-&gt;destination(&quot;host2.example.net&quot;);
$filters-&gt;time_range(86400);
$filters-&gt;event_type(&#39;throughput&#39;);

# Connect to api
my $client = new perfSONAR_PS::Client::Esmond::ApiConnect(
    url =&gt; &#39;http://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);

#get measurements matching filters
my $md = $client-&gt;get_metadata();
die $client-&gt;error if($client-&gt;error); #check for errors
#loop through all measurements
foreach my $m(@{$md}){
    # get data of a particular event type
    my $et = $m-&gt;get_event_type(&quot;throughput&quot;);
    my $data = $et-&gt;get_data();
    die $et-&gt;error if($et-&gt;error); #check for errors
    #print all data
    foreach my $d(@{$data}){
        print &quot;Time: &quot; . $d-&gt;datetime . &quot;, Value: &quot; . $d-&gt;val . &quot;\n&quot;;
    }
}
</pre></div>
</div>
</div>
<div class="section" id="querying-delay-one-way-delay">
<h4>Querying Delay/One-way Delay<a class="headerlink" href="#querying-delay-one-way-delay" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre># define filters
my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters();
$filters-&gt;source(&quot;host1.example.net&quot;);
$filters-&gt;destination(&quot;host2.example.net&quot;);
$filters-&gt;time_range(86400);

# connect to api
my $client = new perfSONAR_PS::Client::Esmond::ApiConnect(
    url =&gt; &#39;http://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);

#get measurements matching filters
my $md = $client-&gt;get_metadata();
die $client-&gt;error if($client-&gt;error); #check for errors
foreach my $m(@{$md}){
    my $et = $m-&gt;get_event_type(&quot;histogram-owdelay&quot;);
    my $data = $et-&gt;get_data();
    die $et-&gt;error if($et-&gt;error); #check for errors
    #base data
    foreach my $d(@{$data}){
        print &quot;Time: &quot; . $d-&gt;datetime . &quot;\n&quot;;
        foreach my $bucket(keys %{$d-&gt;val}){
            print &quot;\t${bucket}ms: &quot; . $d-&gt;val-&gt;{$bucket} . &quot;\n&quot;;
        }
    }

    #get histogram statistics summary for base data
    my $stats_summ = $et-&gt;get_summary(&#39;statistics&#39;, 0);
    next unless($stats_summ);
    my $stats_data = $stats_summ-&gt;get_data();
    die $stats_summ-&gt;error if($stats_summ-&gt;error);
    foreach my $stats_d(@{$stats_data}){
        print &quot;Time: &quot; . $stats_d-&gt;datetime . &quot;, Median:&quot; . $stats_d-&gt;{val}-&gt;{median}. &quot;\n&quot;;
    }

    #get 24 hour summaries
    my $agg_summ = $et-&gt;get_summary(&#39;aggregation&#39;, 86400);
    next unless($agg_summ);
    my $agg_data = $agg_summ-&gt;get_data();
    return $agg_summ-&gt;error if($agg_summ-&gt;error);
    foreach my $agg_d(@{$agg_data}){
        foreach my $agg_bucket(keys %{$agg_d-&gt;val}){
            print &quot;\t${agg_bucket}ms: &quot; . $agg_d-&gt;val-&gt;{$agg_bucket}. &quot;\n&quot;;
        }
    }
}
</pre></div>
</div>
</div>
<div class="section" id="querying-packet-loss">
<h4>Querying Packet Loss<a class="headerlink" href="#querying-packet-loss" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>#define filters
my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters();
$filters-&gt;source(&quot;host1.example.net&quot;);
$filters-&gt;destination(&quot;host2.example.net&quot;);
$filters-&gt;time_range(86400);

# connect to api
my $client = new perfSONAR_PS::Client::Esmond::ApiConnect(
    url =&gt; &#39;http://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);

#get measurements matching filters
my $md = $client-&gt;get_metadata();
die $client-&gt;error if($client-&gt;error); #check for errors
foreach my $m(@{$md}){
    my $et = $m-&gt;get_event_type(&quot;packet-loss-rate&quot;);
    my $data = $et-&gt;get_data();
    die $et-&gt;error if($et-&gt;error); #check for errors
    #base data
    foreach my $d(@{$data}){
        print &quot;Time: &quot; . $d-&gt;datetime . &quot;, Loss: &quot; . $d-&gt;val*100.0 . &quot;%\n&quot;;
    }

    #get 24 hour summaries
    my $agg_summ = $et-&gt;get_summary(&#39;aggregation&#39;, 86400);
    next unless($agg_summ);
    my $agg_data = $agg_summ-&gt;get_data();
    return $agg_summ-&gt;error if($agg_summ-&gt;error);
    foreach my $agg_d(@{$agg_data}){
        print &quot;Time: &quot; . $agg_d-&gt;datetime . &quot;, Loss: &quot; . $agg_d-&gt;val*100.0 . &quot;%\n&quot;;
    }
}
</pre></div>
</div>
</div>
<div class="section" id="querying-packet-traces">
<h4>Querying Packet Traces<a class="headerlink" href="#querying-packet-traces" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>#define filters
my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters();
$filters-&gt;source(&quot;host1.example.net&quot;);
$filters-&gt;destination(&quot;host2.example.net&quot;);
$filters-&gt;time_range(86400);

# connect to api
my $client = new perfSONAR_PS::Client::Esmond::ApiConnect(
    url =&gt; &#39;http://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);

#get measurements matching filters
my $md = $client-&gt;get_metadata();
die $client-&gt;error if($client-&gt;error); #check for errors
foreach my $m(@{$md}){
    my $et = $m-&gt;get_event_type(&quot;packet-trace&quot;);
    my $data = $et-&gt;get_data();
    die $et-&gt;error if($et-&gt;error); #check for errors
    #base data
    foreach my $d(@{$data}){
        print &quot;Time: &quot; . $d-&gt;datetime . &quot;\n&quot;;
        foreach my $hop(@{$d-&gt;val}){
            print &quot;ttl=&quot; . $hop-&gt;ttl . &quot;,query=&quot; . $hop-&gt;query;
            if($hop-&gt;{success}){
                print &quot;,ip=&quot; . $hop-&gt;{ip} . &quot;,rtt=&quot; . $hop-&gt;{rtt} . &quot;,mtu=&quot; . $hop-&gt;{mtu} . &quot;\n&quot;;
            }else{
                print &quot;,error=&quot; . $hop-&gt;{error} . &quot;\n&quot;;
            }
        }
    }
}
</pre></div>
</div>
</div>
<div class="section" id="querying-subintervals">
<h4>Querying Subintervals<a class="headerlink" href="#querying-subintervals" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre># Define filters
my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters();
$filters-&gt;source(&quot;host1.example.net&quot;);
$filters-&gt;destination(&quot;host2.example.net&quot;);
$filters-&gt;time_range(86400);
$filters-&gt;event_type(&#39;packet-retransmits-subintervals&#39;);

# Connect to api
my $client = new perfSONAR_PS::Client::Esmond::ApiConnect(
    url =&gt; &#39;http://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);

#get measurements matching filters
my $md = $client-&gt;get_metadata();
die $client-&gt;error if($client-&gt;error); #check for errors
#loop through all measurements
foreach my $m(@{$md}){
    # get data of a particular event type
    my $et = $m-&gt;get_event_type(&quot;packet-retransmits-subintervals&quot;);
    my $data = $et-&gt;get_data();
    die $et-&gt;error if($et-&gt;error); #check for errors
    #print all data
    foreach my $d(@{$data}){
        print &quot;Time: &quot; . $d-&gt;datetime . &quot;\n&quot;;
        foreach my $subint(@{$d-&gt;val}){
            print &quot;\tstart=&quot; . $subint-&gt;{start} . &quot;,duration=&quot; . $subint-&gt;{duration} . &quot;,value=&quot; . $subint-&gt;{val} . &quot;\n&quot;;
        }
    }
}
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="publishing-data">
<h2>Publishing Data<a class="headerlink" href="#publishing-data" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Quickstart<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>#define filters with authentication information
my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters(
    &#39;auth_username&#39; =&gt; &#39;perfsonar&#39;,
    &#39;auth_apikey&#39; =&gt; &#39;8208b9ad15dbda8e91cb086b0d228857de99fa25&#39;,
    &#39;ca_certificate_file&#39; =&gt; &#39;/etc/pki/tls/bundle.crt&#39;
);

#Post measurement metadata
my $metadata = new perfSONAR_PS::Client::Esmond::Metadata(
    url =&gt; &#39;https://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);
$metadata-&gt;subject_type(&#39;point-to-point&#39;);
$metadata-&gt;source(&#39;10.1.1.1&#39;);
$metadata-&gt;destination(&#39;10.1.1.2&#39;);
$metadata-&gt;input_source(&#39;host1.example.net&#39;);
$metadata-&gt;input_destination(&#39;host2.example.net&#39;);
$metadata-&gt;tool_name(&#39;bwctl/iperf3&#39;);
$metadata-&gt;measurement_agent(&#39;10.1.1.1&#39;);
$metadata-&gt;set_field(&#39;time-interval&#39;, 21600);
$metadata-&gt;set_field(&#39;time-duration&#39;, 20);
$metadata-&gt;add_event_type(&#39;throughput&#39;);
$metadata-&gt;add_summary_type(&#39;throughput&#39;, &#39;average&#39;, 86400);
$metadata-&gt;add_event_type(&#39;packet-retransmits&#39;);
$metadata-&gt;post_metadata();
die $metadata-&gt;error() if $metadata-&gt;error();

#post data to single event type
my $et = $metadata-&gt;get_event_type(&#39;throughput&#39;);
my $data = new perfSONAR_PS::Client::Esmond::DataPayload(&#39;ts&#39; =&gt; time. &#39;&#39;, &#39;val&#39; =&gt; 1000000000);
$et-&gt;post_data($data);
die $et-&gt;error() if $et-&gt;error();

#post multiple time series to multiple event types
my $bulk_post = $metadata-&gt;generate_event_type_bulk_post();
my $ts = time;
$bulk_post-&gt;add_data_point(&#39;throughput&#39;, $ts, 2000000000);
$bulk_post-&gt;add_data_point(&#39;packet-retransmits&#39;, $ts, 10);
$bulk_post-&gt;add_data_point(&#39;throughput&#39;, $ts-1800, 1000000000);
$bulk_post-&gt;add_data_point(&#39;packet-retransmits&#39;, $ts-1800, 9);
$bulk_post-&gt;post_data();
die $bulk_post-&gt;error() if $bulk_post-&gt;error();
</pre></div>
</div>
</div>
<div class="section" id="authentication-and-authorization">
<h3>Authentication and Authorization<a class="headerlink" href="#authentication-and-authorization" title="Permalink to this headline">¶</a></h3>
<p>Writing data generally requires authentication and authorization. You can define authentication-related parameters using the options defined in the first table under <a class="reference internal" href="#psclient-perl-filters"><em>Defining filters</em></a>. Specifically the option <strong>auth_username</strong> and <strong>auth_apikey</strong> are important for setting your user credentials. It is also highly recommended you send the message over HTTPS so the credentials are not sent plain-text (especially when sending to an external host). You may control HTTPS settings with the options <strong>ca_certificate_file</strong>, <strong>ca_certificate_path</strong> and/or <strong>verify_hostname</strong>. For example:</p>
<div class="highlight-python"><div class="highlight"><pre>my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters(
    &#39;auth_username&#39; =&gt; &#39;perfsonar&#39;,
    &#39;auth_apikey&#39; =&gt; &#39;8208b9ad15dbda8e91cb086b0d228857de99fa25&#39;,
    &#39;ca_certificate_file&#39; =&gt; &#39;/etc/pki/tls/bundle.crt&#39;
);
</pre></div>
</div>
</div>
<div class="section" id="publishing-the-measurement-description">
<span id="psclient-perl-publish-metadata"></span><h3>Publishing the Measurement Description<a class="headerlink" href="#publishing-the-measurement-description" title="Permalink to this headline">¶</a></h3>
<p>Publishing a new description of a measurement&#8217;s parameters requires the instantiation of a new <em>perfSONAR_PS::Client::Esmond::Metadata</em> object. Notice this is the same object returned when querying as described in <a class="reference internal" href="#psclient-perl-metadata"><em>Working with Measurement Metadata</em></a>. This also means if you want to post data to an existing test, you can use the Metadata object returned directly. Assuming you are using a completely new object though, the object provides a number of setters for common fields:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Method Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>source(ip)</strong></td>
<td>An IP address representing the sender in a point-to-point measurement</td>
</tr>
<tr class="row-odd"><td><strong>destination(ip)</strong></td>
<td>An IP address representing the receiver in a point-to-point measurement</td>
</tr>
<tr class="row-even"><td><strong>measurement_agent(ip)</strong></td>
<td>The IP address of the host that initiated the measurement</td>
</tr>
<tr class="row-odd"><td><strong>metadata_key(string)</strong></td>
<td>The key used to identify this metadata_object.</td>
</tr>
<tr class="row-even"><td><strong>input_source(string)</strong></td>
<td>A string representing the source address exactly as it is passed to the underlying measurement tool.</td>
</tr>
<tr class="row-odd"><td><strong>input_destination(string)</strong></td>
<td>A string representing the destination address exactly as it is passed to the underlying measurement tool.</td>
</tr>
<tr class="row-even"><td><strong>subject_type(string)</strong></td>
<td>Indicates the type of parameters to expect in the metadata. In general will always be <em>point-to-point</em>.</td>
</tr>
<tr class="row-odd"><td><strong>tool_name(string)</strong></td>
<td>The name of the tool used to run the underlying measurement.</td>
</tr>
</tbody>
</table>
<p>In addition you may set context-specific fields with the <em>set_field</em> subroutine that accepts the field name and the value to assign (<em>NOTE: The value must be a primitive type such as a number or string</em>):</p>
<div class="highlight-python"><div class="highlight"><pre>$metadata-&gt;set_field(&#39;time-interval&#39;, 21600);
</pre></div>
</div>
<p>There are a few special methods for adding new event types and summaries:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Method Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>add_event_type(event-type)</strong></td>
<td>Accepts a string with the event type (e.g. <em>throughput</em>, <em>histogram-owdelay</em>, <em>packet-loss-rate</em>) and adds it to the metadata.</td>
</tr>
<tr class="row-odd"><td><strong>add_summary_type(event-type, summary-type, summary-window)</strong></td>
<td>Adds a summary of the given <em>summary-type</em> (e.g. <em>average</em>. <em>aggregation</em>, or <em>statistics</em>) over the given <em>summary_window</em> (in seconds) for the given <em>event-type</em>.</td>
</tr>
</tbody>
</table>
<p>An example of these methods is provided below:</p>
<div class="highlight-python"><div class="highlight"><pre>$metadata-&gt;add_event_type(&#39;throughput&#39;);
$metadata-&gt;add_summary_type(&#39;throughput&#39;, &#39;average&#39;, 86400);
$metadata-&gt;add_event_type(&#39;packet-retransmits&#39;);
</pre></div>
</div>
<p>The final step of creating the new metadata is to call the <em>post_metadata()</em> method:</p>
<div class="highlight-python"><div class="highlight"><pre>$metadata-&gt;post_metadata();
</pre></div>
</div>
<p>This sends an HTTP POST request to the server. If the request fails for any reason, there will be an error message returned by a call to the <em>error()</em> method. If it succeeds, the Metadata object will contain the resulting URIs and metadata_key in addition to the parameters already set. Also remember that if the server determines there is a metadata object that exactly matches, it will return the existing result instead of creating a duplicate. The resulting object can also be used to post measurement results as described in the next few sections.</p>
</div>
<div class="section" id="publishing-a-single-measurement-result">
<h3>Publishing a Single Measurement Result<a class="headerlink" href="#publishing-a-single-measurement-result" title="Permalink to this headline">¶</a></h3>
<p>Once you have the Metadata object by either creating your own as described in <a class="reference internal" href="#psclient-perl-publish-metadata"><em>Publishing the Measurement Description</em></a> or querying an existing one as described in <a class="reference internal" href="#psclient-perl-metadata"><em>Working with Measurement Metadata</em></a>, you can then retrieve a <em>perfSONAR_PS::Client::Esmond::EventType</em> object with the following:</p>
<div class="highlight-python"><div class="highlight"><pre>my $et = $metadata-&gt;get_event_type(&#39;throughput&#39;);
</pre></div>
</div>
<p>You can then post to this event type by creating a new <em>perfSONAR_PS::Client::Esmond::DataPayload</em> with a <em>ts</em> field indicating the time the measurement was performed and a <em>val</em> indicating the result. The <em>perfSONAR_PS::Client::Esmond::DataPayload</em> module is described in detail in <a class="reference internal" href="#psclient-perl-query-base"><em>Querying Base Measurement Results</em></a> but an example is below:</p>
<div class="highlight-python"><div class="highlight"><pre>my $data = new perfSONAR_PS::Client::Esmond::DataPayload(&#39;ts&#39; =&gt; time. &#39;&#39;, &#39;val&#39; =&gt; 1000000000);
</pre></div>
</div>
<p>We then publish the result with the following call to <em>post_data</em> that accepts a single <em>perfSONAR_PS::Client::Esmond::DataPayload</em> parameter:</p>
<div class="highlight-python"><div class="highlight"><pre>$et-&gt;post_data($data);
</pre></div>
</div>
<p>If the request succeeds then the <em>error()</em> method will return an empty result. The error() method will contain a message describing the problem if something goes wrong. See an example that kills the running program if an error is encountered:</p>
<div class="highlight-python"><div class="highlight"><pre>die $et-&gt;error() if $et-&gt;error();
</pre></div>
</div>
</div>
<div class="section" id="publishing-multiple-measurement-results">
<h3>Publishing Multiple Measurement Results<a class="headerlink" href="#publishing-multiple-measurement-results" title="Permalink to this headline">¶</a></h3>
<p>In addition to publishing single measurements, you may also perform bulk requests for multiple event types and multiple timestamps. All bulk requests go to the same Metadata object. As with the single result case, we must first <a class="reference internal" href="#psclient-perl-publish-metadata"><em>create</em></a> or <a class="reference internal" href="#psclient-perl-metadata"><em>retrieve</em></a> a Metadata object. We can do this be asking the metadata object to generate a <em>perfSONAR_PS::Client::Esmond::EventTypeBulkPost</em> instance (<em>NOTE: Do not construct perfSONAR_PS::Client::Esmond::EventTypeBulkPost directly, retrieve it from the Metadata object</em>):</p>
<div class="highlight-python"><div class="highlight"><pre>my $bulk_post = $metadata-&gt;generate_event_type_bulk_post();
</pre></div>
</div>
<p>You can then add multiple data points with the <em>add_data_point</em> subroutine:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Method Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td><strong>add_data_point(event-type, timestamp, value)</strong></td>
<td>Adds a new data point to publish for the given event-type string (<em>event-type</em>) at the given UNIX timestamp(<em>ts</em>) with the given value (<em>val</em>)</td>
</tr>
</tbody>
</table>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>my $ts = time;
$bulk_post-&gt;add_data_point(&#39;throughput&#39;, $ts, 2000000000);
$bulk_post-&gt;add_data_point(&#39;packet-retransmits&#39;, $ts, 10);
$bulk_post-&gt;add_data_point(&#39;throughput&#39;, $ts-1800, 1000000000);
$bulk_post-&gt;add_data_point(&#39;packet-retransmits&#39;, $ts-1800, 9);
</pre></div>
</div>
<p>Finally, you can send the result and check for errors from the server with the <em>post_data()</em> and <em>error()</em> functions as shown below:</p>
<div class="highlight-python"><div class="highlight"><pre>$bulk_post-&gt;post_data();
die $bulk_post-&gt;error() if $bulk_post-&gt;error();
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>Examples<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<div class="section" id="publishing-throughput-data">
<h4>Publishing Throughput Data<a class="headerlink" href="#publishing-throughput-data" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>#Define filters with authentication information
my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters(
    &#39;auth_username&#39; =&gt; &#39;perfsonar&#39;,
    &#39;auth_apikey&#39; =&gt; &#39;8208b9ad15dbda8e91cb086b0d228857de99fa25&#39;,
    &#39;ca_certificate_file&#39; =&gt; &#39;/etc/pki/tls/bundle.crt&#39;
);

#Post measurement metadata
my $metadata = new perfSONAR_PS::Client::Esmond::Metadata(
    url =&gt; &#39;https://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);
$metadata-&gt;subject_type(&#39;point-to-point&#39;);
$metadata-&gt;source(&#39;10.1.1.1&#39;);
$metadata-&gt;destination(&#39;10.1.1.2&#39;);
$metadata-&gt;input_source(&#39;host1.example.net&#39;);
$metadata-&gt;input_destination(&#39;host2.example.net&#39;);
$metadata-&gt;tool_name(&#39;bwctl/iperf3&#39;);
$metadata-&gt;measurement_agent(&#39;10.1.1.1&#39;);
$metadata-&gt;set_field(&#39;ip-transport-protocol&#39;, &#39;tcp&#39;);
$metadata-&gt;set_field(&#39;time-duration&#39;, 20);
$metadata-&gt;set_field(&#39;time-interval&#39;, 21600);
$metadata-&gt;set_field(&#39;bw-parallel-streams&#39;, 1);
$metadata-&gt;add_event_type(&#39;throughput&#39;);
$metadata-&gt;add_summary_type(&#39;throughput&#39;, &#39;average&#39;, 86400);
$metadata-&gt;add_event_type(&#39;failures&#39;);
$metadata-&gt;add_event_type(&#39;packet-retransmits&#39;);
$metadata-&gt;post_metadata();
die $metadata-&gt;error() . &quot;\n&quot; if $metadata-&gt;error();

#Bulk post data
my $bulk_post = $metadata-&gt;generate_event_type_bulk_post();
my $ts = time;
$bulk_post-&gt;add_data_point(&#39;throughput&#39;, $ts, 2000000000);
$bulk_post-&gt;add_data_point(&#39;packet-retransmits&#39;, $ts, 10);
$bulk_post-&gt;post_data();
die $bulk_post-&gt;error() if($bulk_post-&gt;error());
</pre></div>
</div>
</div>
<div class="section" id="publishing-delay-ping-data">
<h4>Publishing Delay(Ping) Data<a class="headerlink" href="#publishing-delay-ping-data" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>#define filters with authentication information
my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters(
    &#39;auth_username&#39; =&gt; &#39;perfsonar&#39;,
    &#39;auth_apikey&#39; =&gt; &#39;8208b9ad15dbda8e91cb086b0d228857de99fa25&#39;,
    &#39;ca_certificate_file&#39; =&gt; &#39;/etc/pki/tls/bundle.crt&#39;
);

#Post measurement metadata
my $metadata = new perfSONAR_PS::Client::Esmond::Metadata(
    url =&gt; &#39;https://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);
$metadata-&gt;subject_type(&#39;point-to-point&#39;);
$metadata-&gt;source(&#39;10.1.1.1&#39;);
$metadata-&gt;destination(&#39;10.1.1.2&#39;);
$metadata-&gt;input_source(&#39;host1.example.net&#39;);
$metadata-&gt;input_destination(&#39;host2.example.net&#39;);
$metadata-&gt;tool_name(&#39;bwctl/ping&#39;);
$metadata-&gt;measurement_agent(&#39;10.1.1.1&#39;);
$metadata-&gt;set_field(&#39;ip-transport-protocol&#39;, &#39;icmp&#39;);
$metadata-&gt;set_field(&#39;ip-packet-size&#39;, 1000);
$metadata-&gt;set_field(&#39;time-interval&#39;, 600);
$metadata-&gt;set_field(&#39;time-probe-interval&#39;, 1);
$metadata-&gt;set_field(&#39;sample-size&#39;, 100);
$metadata-&gt;add_event_type(&#39;histogram-rtt&#39;);
$metadata-&gt;add_summary_type(&#39;histogram-rtt&#39;, &#39;aggregation&#39;, 86400);
$metadata-&gt;add_summary_type(&#39;histogram-rtt&#39;, &#39;statistics&#39;, 0);
$metadata-&gt;add_summary_type(&#39;histogram-rtt&#39;, &#39;statistics&#39;, 86400);
$metadata-&gt;add_event_type(&#39;packet-loss-rate-bidir&#39;);
$metadata-&gt;add_summary_type(&#39;packet-loss-rate-bidir&#39;, &#39;aggregation&#39;, 3600);
$metadata-&gt;add_summary_type(&#39;packet-loss-rate-bidir&#39;, &#39;aggregation&#39;, 86400);
$metadata-&gt;add_event_type(&#39;histogram-ttl-reverse&#39;);
$metadata-&gt;add_summary_type(&#39;histogram-ttl-reverse&#39;, &#39;statistics&#39;, 0);
$metadata-&gt;add_event_type(&#39;packet-count-lost-bidir&#39;);
$metadata-&gt;add_event_type(&#39;packet-count-sent&#39;);
$metadata-&gt;add_event_type(&#39;packet-duplicates-bidir&#39;);
$metadata-&gt;add_event_type(&#39;packet-reorders-bidir&#39;);
$metadata-&gt;add_event_type(&#39;failures&#39;);
$metadata-&gt;post_metadata();
die $metadata-&gt;error() . &quot;\n&quot; if $metadata-&gt;error();

#bulk post data
my $bulk_post = $metadata-&gt;generate_event_type_bulk_post();
my $ts = time;
$bulk_post-&gt;add_data_point(&#39;histogram-rtt&#39;, $ts, { &#39;41.00&#39;=&gt; 99, &#39;41.10&#39;=&gt; 1 });
$bulk_post-&gt;add_data_point(&#39;packet-loss-rate&#39;, $ts, {&#39;numerator&#39;=&gt; 0, &#39;denominator&#39;=&gt; 100});
$bulk_post-&gt;add_data_point(&#39;histogram-ttl&#39;, $ts, { &#39;59&#39;=&gt; 100 });
$bulk_post-&gt;add_data_point(&#39;packet-count-lost&#39;, $ts, 0);
$bulk_post-&gt;add_data_point(&#39;packet-count-sent&#39;, $ts, 100);
$bulk_post-&gt;add_data_point(&#39;packet-duplicates&#39;, $ts, 0);
$bulk_post-&gt;add_data_point(&#39;packet-reorders&#39;, $ts, 0);
$bulk_post-&gt;post_data();
die $bulk_post-&gt;error() if($bulk_post-&gt;error());
</pre></div>
</div>
</div>
<div class="section" id="publishing-one-way-delay-owamp-data">
<h4>Publishing One-way Delay(OWAMP) Data<a class="headerlink" href="#publishing-one-way-delay-owamp-data" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>#define filters with authentication information
my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters(
    &#39;auth_username&#39; =&gt; &#39;perfsonar&#39;,
    &#39;auth_apikey&#39; =&gt; &#39;8208b9ad15dbda8e91cb086b0d228857de99fa25&#39;,
    &#39;ca_certificate_file&#39; =&gt; &#39;/etc/pki/tls/bundle.crt&#39;
);

#Post measurement metadata
my $metadata = new perfSONAR_PS::Client::Esmond::Metadata(
    url =&gt; &#39;https://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);
$metadata-&gt;subject_type(&#39;point-to-point&#39;);
$metadata-&gt;source(&#39;10.1.1.1&#39;);
$metadata-&gt;destination(&#39;10.1.1.2&#39;);
$metadata-&gt;input_source(&#39;host1.example.net&#39;);
$metadata-&gt;input_destination(&#39;host2.example.net&#39;);
$metadata-&gt;tool_name(&#39;powstream&#39;);
$metadata-&gt;measurement_agent(&#39;10.1.1.1&#39;);
$metadata-&gt;set_field(&#39;ip-transport-protocol&#39;, &#39;udp&#39;);
$metadata-&gt;set_field(&#39;ip-packet-size&#39;, 100);
$metadata-&gt;set_field(&#39;time-interval&#39;, 0);
$metadata-&gt;set_field(&#39;time-probe-interval&#39;, .1);
$metadata-&gt;set_field(&#39;sample-size&#39;, 600);
$metadata-&gt;set_field(&#39;sample-bucket-width&#39;, .0001);
$metadata-&gt;add_event_type(&#39;histogram-owdelay&#39;);
$metadata-&gt;add_summary_type(&#39;histogram-owdelay&#39;, &#39;aggregation&#39;, 3600);
$metadata-&gt;add_summary_type(&#39;histogram-owdelay&#39;, &#39;aggregation&#39;, 86400);
$metadata-&gt;add_summary_type(&#39;histogram-owdelay&#39;, &#39;statistics&#39;, 0);
$metadata-&gt;add_summary_type(&#39;histogram-owdelay&#39;, &#39;statistics&#39;, 3600);
$metadata-&gt;add_summary_type(&#39;histogram-owdelay&#39;, &#39;statistics&#39;, 86400);
$metadata-&gt;add_event_type(&#39;packet-loss-rate&#39;);
$metadata-&gt;add_summary_type(&#39;packet-loss-rate&#39;, &#39;aggregation&#39;, 3600);
$metadata-&gt;add_summary_type(&#39;packet-loss-rate&#39;, &#39;aggregation&#39;, 86400);
$metadata-&gt;add_event_type(&#39;histogram-ttl&#39;);
$metadata-&gt;add_summary_type(&#39;histogram-ttl&#39;, &#39;statistics&#39;, 0);
$metadata-&gt;add_event_type(&#39;packet-count-lost&#39;);
$metadata-&gt;add_event_type(&#39;packet-count-sent&#39;);
$metadata-&gt;add_event_type(&#39;packet-duplicates&#39;);
$metadata-&gt;add_event_type(&#39;time-error-estimates&#39;);
$metadata-&gt;add_event_type(&#39;failures&#39;);
$metadata-&gt;post_metadata();
die $metadata-&gt;error() . &quot;\n&quot; if $metadata-&gt;error();

#bulk post data
my $bulk_post = $metadata-&gt;generate_event_type_bulk_post();
my $ts = time;
$bulk_post-&gt;add_data_point(&#39;histogram-owdelay&#39;, $ts, { &#39;34.5&#39;=&gt; 30, &#39;34.3&#39;=&gt; 440, &#39;34.6&#39; =&gt; 7, &#39;34.4&#39; =&gt; 123 });
$bulk_post-&gt;add_data_point(&#39;packet-loss-rate&#39;, $ts, {&#39;numerator&#39;=&gt; 0, &#39;denominator&#39;=&gt; 600});
$bulk_post-&gt;add_data_point(&#39;histogram-ttl&#39;, $ts, { &#39;59&#39;=&gt; 600 });
$bulk_post-&gt;add_data_point(&#39;packet-count-lost&#39;, $ts, 0);
$bulk_post-&gt;add_data_point(&#39;packet-count-sent&#39;, $ts, 600);
$bulk_post-&gt;add_data_point(&#39;packet-duplicates&#39;, $ts, 0);
$bulk_post-&gt;add_data_point(&#39;time-error-estimates&#39;, $ts, 0.000124);
$bulk_post-&gt;post_data();
die $bulk_post-&gt;error() if($bulk_post-&gt;error());
</pre></div>
</div>
</div>
<div class="section" id="publishing-packet-loss">
<h4>Publishing Packet Loss<a class="headerlink" href="#publishing-packet-loss" title="Permalink to this headline">¶</a></h4>
<p>Note that <em>packet-loss-rate</em> is a special percentage type and thus is not registered as a simple float. It is registered as an object with a <em>numerator</em> and a <em>denominator</em> so that it is easier to summarize. Packet loss is measured by tools such as owamp  (packet-loss-rate) and ping (packet-loss-rate-bidir), but the data registration portion is repeated below to highlight this difference:</p>
<div class="highlight-python"><div class="highlight"><pre>...
$bulk_post-&gt;add_data_point(&#39;packet-loss-rate&#39;, $ts, {&#39;numerator&#39;=&gt; 0, &#39;denominator&#39;=&gt; 100});
...
</pre></div>
</div>
</div>
<div class="section" id="publishing-packet-traces">
<h4>Publishing Packet Traces<a class="headerlink" href="#publishing-packet-traces" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>#define filters with authentication information
my $filters = new perfSONAR_PS::Client::Esmond::ApiFilters(
    &#39;auth_username&#39; =&gt; &#39;perfsonar&#39;,
    &#39;auth_apikey&#39; =&gt; &#39;8208b9ad15dbda8e91cb086b0d228857de99fa25&#39;,
    &#39;ca_certificate_file&#39; =&gt; &#39;/etc/pki/tls/bundle.crt&#39;
);

#Post measurement metadata
my $metadata = new perfSONAR_PS::Client::Esmond::Metadata(
    url =&gt; &#39;https://archive.example.net/esmond/perfsonar/archive&#39;,
    filters =&gt; $filters
);
$metadata-&gt;subject_type(&#39;point-to-point&#39;);
$metadata-&gt;source(&#39;10.1.1.1&#39;);
$metadata-&gt;destination(&#39;10.1.1.2&#39;);
$metadata-&gt;input_source(&#39;host1.example.net&#39;);
$metadata-&gt;input_destination(&#39;host2.example.net&#39;);
$metadata-&gt;tool_name(&#39;bwctl/tracepath&#39;);
$metadata-&gt;measurement_agent(&#39;10.1.1.1&#39;);
$metadata-&gt;set_field(&#39;ip-transport-protocol&#39;, &#39;icmp&#39;);
$metadata-&gt;set_field(&#39;time-interval&#39;, 600);
$metadata-&gt;add_event_type(&#39;failures&#39;);
$metadata-&gt;add_event_type(&#39;packet-trace&#39;);
$metadata-&gt;add_event_type(&#39;path-mtu&#39;);
$metadata-&gt;post_metadata();
die $metadata-&gt;error() . &quot;\n&quot; if $metadata-&gt;error();

#bulk post data
my $bulk_post = $metadata-&gt;generate_event_type_bulk_post();
my $ts = time;
$bulk_post-&gt;add_data_point(&#39;packet-trace&#39;, $ts,[
    {
    &quot;success&quot; =&gt; 1,
    &quot;error_message&quot; =&gt; undef,
    &quot;ip&quot; =&gt; &quot;10.1.1.1&quot;,
    &quot;query&quot; =&gt; &quot;1&quot;,
    &quot;ttl&quot; =&gt; &quot;1&quot;,
    &quot;rtt&quot; =&gt; &quot;0.278&quot;,
    &quot;mtu&quot; =&gt; &quot;9000&quot;
    },
    {
    &quot;success&quot; =&gt; 1,
    &quot;error_message&quot; =&gt; undef,
    &quot;ip&quot; =&gt; &quot;10.1.1.10&quot;,
    &quot;query&quot; =&gt; &quot;1&quot;,
    &quot;ttl&quot; =&gt; &quot;2&quot;,
    &quot;rtt&quot; =&gt; &quot;22.243&quot;,
    &quot;mtu&quot; =&gt; &quot;9000&quot;
    },
    {
    &quot;success&quot; =&gt; 1,
    &quot;error_message&quot; =&gt; undef,
    &quot;ip&quot; =&gt; &quot;10.1.1.12&quot;,
    &quot;query&quot; =&gt; &quot;1&quot;,
    &quot;ttl&quot; =&gt; &quot;3&quot;,
    &quot;rtt&quot; =&gt; &quot;22.516&quot;,
    &quot;mtu&quot; =&gt; &quot;9000&quot;
    },
    {
    &quot;success&quot; =&gt; 1,
    &quot;error_message&quot; =&gt; undef,
    &quot;ip&quot; =&gt; &quot;10.1.1.2&quot;,
    &quot;query&quot; =&gt; &quot;1&quot;,
    &quot;ttl&quot; =&gt; &quot;4&quot;,
    &quot;rtt&quot; =&gt; &quot;68.931&quot;,
    &quot;mtu&quot; =&gt; &quot;9000&quot;
    }
]);
$bulk_post-&gt;add_data_point(&#39;path-mtu&#39;, $ts, 9000);
$bulk_post-&gt;post_data();
die $bulk_post-&gt;error() if($bulk_post-&gt;error());
</pre></div>
</div>
</div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <div class="row">
      <div class="col-md-1">
        <a href="http://www.es.net/"><img src="_static/esnet/logo-esnet.png" alt="[ESnet]"></a>
      </div>
      <div class="col-md-11">
        <p class="pull-right">
        <a href="#">Back to top</a>
        
        <br/>
        
<div id="sourcelink">
  <a href="_sources/perfsonar_client_perl.txt"
     rel="nofollow">Source</a>
</div>
        
        </p>
        <p>
            &copy; Copyright 2012-2013, The Regents of the University of California.<br/>
          Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2.<br/>
        </p>
      </div>
    </div>
  </div>
</footer>
  </body>
</html>