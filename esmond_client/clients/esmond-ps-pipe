#!/usr/bin/env python

"""
esmond-ps-pipe - take piped json output from bwctl and load into an esmond 
perfsonar MA. To wit:

bwctl -c lbl-pt1.es.net -s llnl-pt1.es.net -T iperf3 --parsable | esmond-ps-pipe -url http://ps-archive.es.net
"""

import datetime
import json
import logging
import os
import sys
import time

from optparse import OptionParser

import pprint

pp = pprint.PrettyPrinter(indent=4)

class EsmondPipeException(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class EsmondPipeWarning(Warning): pass

def setup_log(log_path=None):
    """
    Usage:
    _log('main.start', 'happy simple log event')
    _log('launch', 'more={0}, complex={1} log=event'.format(100, 200))
    """
    log = logging.getLogger("esmond-ps-pipe")
    if not log_path:
        _h = logging.StreamHandler()
    else:
        # it's on you to make sure log_path is valid.
        logfile = '{0}/esmond-ps-pipe.log'.format(log_path)
        _h = logging.FileHandler(logfile)
    _h.setFormatter(logging.Formatter('ts=%(asctime)s %(message)s'))
    log.addHandler(_h)
    log.setLevel(logging.INFO)
    return log

class RecursiveDataObject(object):
    def __init__(self, initial=None):
        self.__dict__['_data'] = {}

        if hasattr(initial, 'items'):
            self.__dict__['_data'] = initial
            try:
                # Recurse through entire all attrs at all levels
                # to make sure the wrapping is ok so we can check
                # the parse once.
                for i in self._data.keys():
                    self._wrap(self._data.get(i), i)
            except Exception as e:
                raise EsmondPipeException(str(e))

    def _wrap(self, data, name):
        # print 'wrap', name
        # dict => wrapper object
        if isinstance(data, dict):
            return RecursiveDataObject(data)
        # list of dicts => list of wrapper objects
        elif isinstance(data, list):
            return [ RecursiveDataObject(x) for x in data ]
        # modify outgoing named attributes
        elif name in ('time','timesecs',):
            return self._to_datetime(data)

        return data

    def _to_datetime(self, d):
        if isinstance(d, int):
            # presume unixtime
            return datetime.datetime.utcfromtimestamp(d)
        else:
            return datetime.datetime.strptime(d, '%a, %d %b %Y %X GMT')

    def __getattr__(self, name):
        return self._wrap(self._data.get(name, None), name)

    def __setattr__(self, name, value):
        self.__dict__['_data'][name] = value

    def __str__(self):
        return pp.pformat(self.to_dict())

    def to_dict(self):
        return self._data

def id_and_extract(data, _log):
    """
    Identify the piped input and isolate the json part.
    """

    class Payload(object):
        tool_type = None
        input_source = None
        input_destination = None
        payload = None

    payload = Payload()

    json_block = ''

    scanning = False

    for i in data:
        ## ignore
        # skip blank lines
        if not i.strip():
            continue
        # skip extraneous output if not scanning the json
        if not scanning and not i.startswith('bwctl:'):
            continue

        ## pull out metadata from the --verbose output
        if i.startswith('bwctl: Using tool:'):
            payload.tool_type = i.split()[3]

        if i.strip().endswith('as the address for remote sender'):
            payload.input_source = i.split()[2]

        if i.strip().endswith('as the address for remote receiver'):
            payload.input_destination = i.split()[2]

        ## scanning logic
        # end scanning token
        if i.startswith('bwctl: stop_tool:'):
            break
        # gather the json
        if scanning:
            json_block += i
        # token to start gathering the json
        if i.startswith('bwctl: start_tool:'):
            scanning = True

    # did we find the scanning tokens?
    if not scanning:
        _log('id_and_extract.error', 'did not find bwctl: start_tool token to extract JSON from output')
        _log('id_and_extract.error', 'bwctl must be run with the --verbose flag')

    # check that appropriate metadata was extracted
    metadata_found = True
    fields = ('tool_type', 'input_source', 'input_destination',)

    for f in fields:
        if not getattr(payload, f):
            metadata_found = False
            _log('id_and_extract.error', 'could not extract {0}'.format(f))

    # parse the json
    try:
        payload.payload = json.loads(json_block)
    except ValueError:
        _log('id_and_extract.error', 'could not load json_block: {0}'.format(json_block))

    # make sure we got everything
    if not payload.payload or not metadata_found:
        return None
    else:
        return payload

def process_iperf3(o, _log):
    _log('process_iperf3.start', 'begin')

    # metadata

    # event type values

    # XXX(mmg) - what is the ts for each of these data points?

    # throughput
    tp = o.end.sum_received.bits_per_second

    # throughput-subintervals
    # XXX(mmg) - the list of dicts will be the value.
    tp_subints = list()

    for i in o.intervals:
        d = dict(
            start=i.sum.start, 
            duration=i.sum.seconds, 
            throughput=i.sum.bits_per_second
        )
        tp_subints.append(RecursiveDataObject(d))

    # packet-count-lost
    # and
    # packet-count-sent
    # and
    # packet-loss-rate
    # XXX(mmg) - need to get example of these to make sure this works.
    if o.start.test_start.protocol == 'UDP':
        pl = ps = None
        # lost
        if o.end.sum.lost_packets:
            pl = o.end.sum.lost_packets
        # sent
        if o.end.sum.packets:
            ps = o.end.sum.packets
        # loss rate
        if pl and ps:
            lr = RecursiveDataObject(dict(numerator=pl, denominator=ps))

    # packet-retransmits
    prt = o.end.sum_sent.retransmits

    # packet-retransmits-subintervals
    # XXX(mmg) - the list of dicts will be the value.
    pr_subints = list()

    for i in o.intervals:
        d = dict(
            start=i.sum.start, 
            duration=i.sum.seconds, 
            retransmits=i.sum.retransmits
        )
        pr_subints.append(RecursiveDataObject(d))

    # streams-packet-retransmits
    # and
    # streams-packet-retransmits-subintervals
    # and
    # streams-throughput
    # and
    # streams-throughput-subintervals
    if o.start.test_start.num_streams == 1: # <--- XXX(mmg) FIX THIS!!!!
        # retrans
        sp_retrans = list()
        for i in o.end.streams:
            # XXX(mmg) - need clarification on this
            pass

        # retrans-subint
        # XXX(mmg) - would be good to get a real example of this
        # to make sure this is all correct.
        sp_retrans_subint = list()
        for i in o.intervals:
            sl = list()
            for ii in i.streams:
                d = dict(
                    start=ii.start, 
                    duration=ii.seconds, 
                    retransmits=ii.retransmits
                )
                sl.append(RecursiveDataObject(d))
            sp_retrans_subint.append(sl)

        # throughput
        for i in o.end.streams:
            # XXX(mmg) - need clarification on this
            # same as above.
            print i

        # throughput-subint
        st_tput_subint = list()
        for i in o.intervals:
            sl = list()
            for ii in i.streams:
                d = dict(
                    start=ii.start, 
                    duration=ii.seconds, 
                    throughput=ii.bits_per_second
                )
                sl.append(RecursiveDataObject(d))
            st_tput_subint.append(sl)
        




    _log('process_iperf3.end', 'finished')


typemap = dict(
    iperf3=process_iperf3,
)

def main():
    usage = ' bwctl ... | %prog [ -u USER -k API_KEY | -U ESMOND_REST_URL | -v ]'
    parser = OptionParser(usage=usage)
    parser.add_option('-U', '--url', metavar='ESMOND_REST_URL',
            type='string', dest='api_url', 
            help='URL for the REST API (default=%default) - required.',
            default='http://localhost:8000')
    parser.add_option('-u', '--user', metavar='USER',
            type='string', dest='user', default='',
            help='POST interface username.')
    parser.add_option('-k', '--key', metavar='API_KEY',
            type='string', dest='key', default='',
            help='API key for POST operation.')
    parser.add_option('-v', '--verbose',
        dest='verbose', action='store_true', default=False,
        help='Verbose output.')
    parser.add_option('-l', '--log_dir', metavar='DIR',
                type='string', dest='logdir', default='',
                help='Write log output to specified directory - if not set, log goes to stdout.')
    options, args = parser.parse_args()

    log_path = None
    
    if options.logdir:
        log_path = os.path.normpath(options.logdir)
        if not os.path.exists(log_path):
            parser.error('{0} log path does not exist.'.format(log_path))
    
    log = setup_log(log_path)
    _log = lambda e, s: log.info('event={e} id={gid} {s}'.format(e=e, gid=int(time.time()), s=s))

    if not options.user or not options.key:
        parser.error('both --user and --key args are required.')

    data = sys.stdin.readlines()
    
    payload = id_and_extract(data, _log)

    if not payload:
        _log('main.fatal', 'could not extract metadata and valid json from input')
        if options.verbose:
            _log('main.debug', '{0}'.format(''.join(data)))
        _log('main.fatal', 'exiting')
        sys.exit(-1)

    try:
        o = RecursiveDataObject(payload.payload)
    except EsmondPipeException as e:
        _log('main.fatal', 'error encapsulating json - ERROR: {0}'.format(str(e)))
        _log('main.fatal', 'exiting')
        sys.exit(-1)

    # process the encapsulated data
    try:
        typemap[payload.tool_type](o, _log)
    except KeyError:
        _log('main.fatal', 'there is no handler for input type: {0}'.format(payload.input_type))
        _log('main.fatal', 'exiting')
    except EsmondPipeException as e:
        _log('main.error', 'unable to process input: {0}'.format(str(e)))

    sys.exit(0)

if __name__ == '__main__':
    main()